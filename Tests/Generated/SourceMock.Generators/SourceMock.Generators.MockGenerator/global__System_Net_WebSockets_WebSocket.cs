#nullable enable
namespace System.Net.WebSockets.Mocks {
    internal class WebSocketMock : global::System.Net.WebSockets.WebSocket, IWebSocketSetup, IWebSocketCalls, SourceMock.IMock<global::System.Net.WebSockets.WebSocket> {
        public IWebSocketSetup Setup => this;
        public IWebSocketCalls Calls => this;

        private readonly SourceMock.Internal.MockMethodHandler _abortHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Action> IWebSocketSetup.Abort() => _abortHandler.Setup<System.Action, SourceMock.Internal.VoidReturn>(null, null);
        public override void Abort() => _abortHandler.Call<System.Action, SourceMock.Internal.VoidReturn>(null, null);
        System.Collections.Generic.IReadOnlyList<SourceMock.NoArguments> IWebSocketCalls.Abort() => _abortHandler.Calls(null, null, _ => SourceMock.NoArguments.Value);

        private readonly SourceMock.Internal.MockMethodHandler _closeAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus,string?,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task> IWebSocketSetup.CloseAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketCloseStatus> closeStatus, SourceMock.Internal.MockArgumentMatcher<string?> statusDescription, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _closeAsyncHandler.Setup<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus,string?,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>(null, new SourceMock.Internal.IMockArgumentMatcher[] { closeStatus, statusDescription, cancellationToken });
        public override global::System.Threading.Tasks.Task CloseAsync(global::System.Net.WebSockets.WebSocketCloseStatus closeStatus, string? statusDescription, global::System.Threading.CancellationToken cancellationToken) => _closeAsyncHandler.Call<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus,string?,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>(null, new object?[] { closeStatus, statusDescription, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.Net.WebSockets.WebSocketCloseStatus closeStatus, string? statusDescription, global::System.Threading.CancellationToken cancellationToken)> IWebSocketCalls.CloseAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketCloseStatus> closeStatus, SourceMock.Internal.MockArgumentMatcher<string?> statusDescription, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _closeAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { closeStatus, statusDescription, cancellationToken }, args => ((global::System.Net.WebSockets.WebSocketCloseStatus)args[0]!, (string?)args[1], (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _closeOutputAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus,string?,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task> IWebSocketSetup.CloseOutputAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketCloseStatus> closeStatus, SourceMock.Internal.MockArgumentMatcher<string?> statusDescription, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _closeOutputAsyncHandler.Setup<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus,string?,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>(null, new SourceMock.Internal.IMockArgumentMatcher[] { closeStatus, statusDescription, cancellationToken });
        public override global::System.Threading.Tasks.Task CloseOutputAsync(global::System.Net.WebSockets.WebSocketCloseStatus closeStatus, string? statusDescription, global::System.Threading.CancellationToken cancellationToken) => _closeOutputAsyncHandler.Call<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus,string?,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>(null, new object?[] { closeStatus, statusDescription, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.Net.WebSockets.WebSocketCloseStatus closeStatus, string? statusDescription, global::System.Threading.CancellationToken cancellationToken)> IWebSocketCalls.CloseOutputAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketCloseStatus> closeStatus, SourceMock.Internal.MockArgumentMatcher<string?> statusDescription, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _closeOutputAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { closeStatus, statusDescription, cancellationToken }, args => ((global::System.Net.WebSockets.WebSocketCloseStatus)args[0]!, (string?)args[1], (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _disposeHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Action> IWebSocketSetup.Dispose() => _disposeHandler.Setup<System.Action, SourceMock.Internal.VoidReturn>(null, null);
        public override void Dispose() => _disposeHandler.Call<System.Action, SourceMock.Internal.VoidReturn>(null, null);
        System.Collections.Generic.IReadOnlyList<SourceMock.NoArguments> IWebSocketCalls.Dispose() => _disposeHandler.Calls(null, null, _ => SourceMock.NoArguments.Value);

        private readonly SourceMock.Internal.MockMethodHandler _receiveAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.ArraySegment<byte>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult>>, global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult>> IWebSocketSetup.ReceiveAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ArraySegment<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _receiveAsyncHandler.Setup<System.Func<global::System.ArraySegment<byte>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult>>, global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult> ReceiveAsync(global::System.ArraySegment<byte> buffer, global::System.Threading.CancellationToken cancellationToken) => _receiveAsyncHandler.Call<System.Func<global::System.ArraySegment<byte>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult>>, global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult>>(null, new object?[] { buffer, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.ArraySegment<byte> buffer, global::System.Threading.CancellationToken cancellationToken)> IWebSocketCalls.ReceiveAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ArraySegment<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _receiveAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, cancellationToken }, args => ((global::System.ArraySegment<byte>)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _receiveAsync2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Memory<byte>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult>>, global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult>> IWebSocketSetup.ReceiveAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Memory<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _receiveAsync2Handler.Setup<System.Func<global::System.Memory<byte>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult>>, global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, cancellationToken });
        public override global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult> ReceiveAsync(global::System.Memory<byte> buffer, global::System.Threading.CancellationToken cancellationToken) => _receiveAsync2Handler.Call<System.Func<global::System.Memory<byte>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult>>, global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult>>(null, new object?[] { buffer, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.Memory<byte> buffer, global::System.Threading.CancellationToken cancellationToken)> IWebSocketCalls.ReceiveAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Memory<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _receiveAsync2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, cancellationToken }, args => ((global::System.Memory<byte>)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _sendAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.ArraySegment<byte>,global::System.Net.WebSockets.WebSocketMessageType,bool,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task> IWebSocketSetup.SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ArraySegment<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType, SourceMock.Internal.MockArgumentMatcher<bool> endOfMessage, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _sendAsyncHandler.Setup<System.Func<global::System.ArraySegment<byte>,global::System.Net.WebSockets.WebSocketMessageType,bool,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, messageType, endOfMessage, cancellationToken });
        public override global::System.Threading.Tasks.Task SendAsync(global::System.ArraySegment<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, bool endOfMessage, global::System.Threading.CancellationToken cancellationToken) => _sendAsyncHandler.Call<System.Func<global::System.ArraySegment<byte>,global::System.Net.WebSockets.WebSocketMessageType,bool,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>(null, new object?[] { buffer, messageType, endOfMessage, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.ArraySegment<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, bool endOfMessage, global::System.Threading.CancellationToken cancellationToken)> IWebSocketCalls.SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ArraySegment<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType, SourceMock.Internal.MockArgumentMatcher<bool> endOfMessage, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _sendAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, messageType, endOfMessage, cancellationToken }, args => ((global::System.ArraySegment<byte>)args[0]!, (global::System.Net.WebSockets.WebSocketMessageType)args[1]!, (bool)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _sendAsync2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.ReadOnlyMemory<byte>,global::System.Net.WebSockets.WebSocketMessageType,bool,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask>, global::System.Threading.Tasks.ValueTask> IWebSocketSetup.SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ReadOnlyMemory<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType, SourceMock.Internal.MockArgumentMatcher<bool> endOfMessage, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _sendAsync2Handler.Setup<System.Func<global::System.ReadOnlyMemory<byte>,global::System.Net.WebSockets.WebSocketMessageType,bool,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask>, global::System.Threading.Tasks.ValueTask>(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, messageType, endOfMessage, cancellationToken });
        public override global::System.Threading.Tasks.ValueTask SendAsync(global::System.ReadOnlyMemory<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, bool endOfMessage, global::System.Threading.CancellationToken cancellationToken) => _sendAsync2Handler.Call<System.Func<global::System.ReadOnlyMemory<byte>,global::System.Net.WebSockets.WebSocketMessageType,bool,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask>, global::System.Threading.Tasks.ValueTask>(null, new object?[] { buffer, messageType, endOfMessage, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.ReadOnlyMemory<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, bool endOfMessage, global::System.Threading.CancellationToken cancellationToken)> IWebSocketCalls.SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ReadOnlyMemory<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType, SourceMock.Internal.MockArgumentMatcher<bool> endOfMessage, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _sendAsync2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, messageType, endOfMessage, cancellationToken }, args => ((global::System.ReadOnlyMemory<byte>)args[0]!, (global::System.Net.WebSockets.WebSocketMessageType)args[1]!, (bool)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _sendAsync3Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.ReadOnlyMemory<byte>,global::System.Net.WebSockets.WebSocketMessageType,global::System.Net.WebSockets.WebSocketMessageFlags,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask>, global::System.Threading.Tasks.ValueTask> IWebSocketSetup.SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ReadOnlyMemory<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageFlags> messageFlags, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _sendAsync3Handler.Setup<System.Func<global::System.ReadOnlyMemory<byte>,global::System.Net.WebSockets.WebSocketMessageType,global::System.Net.WebSockets.WebSocketMessageFlags,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask>, global::System.Threading.Tasks.ValueTask>(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, messageType, messageFlags, cancellationToken });
        public override global::System.Threading.Tasks.ValueTask SendAsync(global::System.ReadOnlyMemory<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, global::System.Net.WebSockets.WebSocketMessageFlags messageFlags, global::System.Threading.CancellationToken cancellationToken) => _sendAsync3Handler.Call<System.Func<global::System.ReadOnlyMemory<byte>,global::System.Net.WebSockets.WebSocketMessageType,global::System.Net.WebSockets.WebSocketMessageFlags,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask>, global::System.Threading.Tasks.ValueTask>(null, new object?[] { buffer, messageType, messageFlags, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.ReadOnlyMemory<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, global::System.Net.WebSockets.WebSocketMessageFlags messageFlags, global::System.Threading.CancellationToken cancellationToken)> IWebSocketCalls.SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ReadOnlyMemory<byte>> buffer, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageFlags> messageFlags, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _sendAsync3Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { buffer, messageType, messageFlags, cancellationToken }, args => ((global::System.ReadOnlyMemory<byte>)args[0]!, (global::System.Net.WebSockets.WebSocketMessageType)args[1]!, (global::System.Net.WebSockets.WebSocketMessageFlags)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockPropertyHandler<global::System.Net.WebSockets.WebSocketCloseStatus?> _closeStatusHandler = new(false);
        SourceMock.Interfaces.IMockPropertySetup<global::System.Net.WebSockets.WebSocketCloseStatus?> IWebSocketSetup.CloseStatus => _closeStatusHandler.Setup();
        public override global::System.Net.WebSockets.WebSocketCloseStatus? CloseStatus => _closeStatusHandler.GetterHandler.Call<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus?>, global::System.Net.WebSockets.WebSocketCloseStatus?>(null, null);
        SourceMock.Interfaces.IMockPropertyCalls<global::System.Net.WebSockets.WebSocketCloseStatus?> IWebSocketCalls.CloseStatus => _closeStatusHandler.Calls();

        private readonly SourceMock.Internal.MockPropertyHandler<string?> _closeStatusDescriptionHandler = new(false);
        SourceMock.Interfaces.IMockPropertySetup<string?> IWebSocketSetup.CloseStatusDescription => _closeStatusDescriptionHandler.Setup();
        public override string? CloseStatusDescription => _closeStatusDescriptionHandler.GetterHandler.Call<System.Func<string?>, string?>(null, null);
        SourceMock.Interfaces.IMockPropertyCalls<string?> IWebSocketCalls.CloseStatusDescription => _closeStatusDescriptionHandler.Calls();

        private readonly SourceMock.Internal.MockPropertyHandler<global::System.Net.WebSockets.WebSocketState> _stateHandler = new(false);
        SourceMock.Interfaces.IMockPropertySetup<global::System.Net.WebSockets.WebSocketState> IWebSocketSetup.State => _stateHandler.Setup();
        public override global::System.Net.WebSockets.WebSocketState State => _stateHandler.GetterHandler.Call<System.Func<global::System.Net.WebSockets.WebSocketState>, global::System.Net.WebSockets.WebSocketState>(null, null);
        SourceMock.Interfaces.IMockPropertyCalls<global::System.Net.WebSockets.WebSocketState> IWebSocketCalls.State => _stateHandler.Calls();

        private readonly SourceMock.Internal.MockPropertyHandler<string?> _subProtocolHandler = new(false);
        SourceMock.Interfaces.IMockPropertySetup<string?> IWebSocketSetup.SubProtocol => _subProtocolHandler.Setup();
        public override string? SubProtocol => _subProtocolHandler.GetterHandler.Call<System.Func<string?>, string?>(null, null);
        SourceMock.Interfaces.IMockPropertyCalls<string?> IWebSocketCalls.SubProtocol => _subProtocolHandler.Calls();
    }

    internal interface IWebSocketSetup {
        SourceMock.Interfaces.IMockMethodSetup<System.Action> Abort();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus,string?,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task> CloseAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketCloseStatus> closeStatus = default, SourceMock.Internal.MockArgumentMatcher<string?> statusDescription = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Net.WebSockets.WebSocketCloseStatus,string?,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task> CloseOutputAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketCloseStatus> closeStatus = default, SourceMock.Internal.MockArgumentMatcher<string?> statusDescription = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Action> Dispose();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.ArraySegment<byte>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult>>, global::System.Threading.Tasks.Task<global::System.Net.WebSockets.WebSocketReceiveResult>> ReceiveAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ArraySegment<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Memory<byte>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult>>, global::System.Threading.Tasks.ValueTask<global::System.Net.WebSockets.ValueWebSocketReceiveResult>> ReceiveAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Memory<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.ArraySegment<byte>,global::System.Net.WebSockets.WebSocketMessageType,bool,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task> SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ArraySegment<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType = default, SourceMock.Internal.MockArgumentMatcher<bool> endOfMessage = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.ReadOnlyMemory<byte>,global::System.Net.WebSockets.WebSocketMessageType,bool,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask>, global::System.Threading.Tasks.ValueTask> SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ReadOnlyMemory<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType = default, SourceMock.Internal.MockArgumentMatcher<bool> endOfMessage = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.ReadOnlyMemory<byte>,global::System.Net.WebSockets.WebSocketMessageType,global::System.Net.WebSockets.WebSocketMessageFlags,global::System.Threading.CancellationToken, global::System.Threading.Tasks.ValueTask>, global::System.Threading.Tasks.ValueTask> SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ReadOnlyMemory<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageFlags> messageFlags = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockPropertySetup<global::System.Net.WebSockets.WebSocketCloseStatus?> CloseStatus { get; }
        SourceMock.Interfaces.IMockPropertySetup<string?> CloseStatusDescription { get; }
        SourceMock.Interfaces.IMockPropertySetup<global::System.Net.WebSockets.WebSocketState> State { get; }
        SourceMock.Interfaces.IMockPropertySetup<string?> SubProtocol { get; }
    }

    internal interface IWebSocketCalls {
        System.Collections.Generic.IReadOnlyList<SourceMock.NoArguments> Abort();
        System.Collections.Generic.IReadOnlyList<(global::System.Net.WebSockets.WebSocketCloseStatus closeStatus, string? statusDescription, global::System.Threading.CancellationToken cancellationToken)> CloseAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketCloseStatus> closeStatus = default, SourceMock.Internal.MockArgumentMatcher<string?> statusDescription = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::System.Net.WebSockets.WebSocketCloseStatus closeStatus, string? statusDescription, global::System.Threading.CancellationToken cancellationToken)> CloseOutputAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketCloseStatus> closeStatus = default, SourceMock.Internal.MockArgumentMatcher<string?> statusDescription = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<SourceMock.NoArguments> Dispose();
        System.Collections.Generic.IReadOnlyList<(global::System.ArraySegment<byte> buffer, global::System.Threading.CancellationToken cancellationToken)> ReceiveAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ArraySegment<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::System.Memory<byte> buffer, global::System.Threading.CancellationToken cancellationToken)> ReceiveAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Memory<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::System.ArraySegment<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, bool endOfMessage, global::System.Threading.CancellationToken cancellationToken)> SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ArraySegment<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType = default, SourceMock.Internal.MockArgumentMatcher<bool> endOfMessage = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::System.ReadOnlyMemory<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, bool endOfMessage, global::System.Threading.CancellationToken cancellationToken)> SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ReadOnlyMemory<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType = default, SourceMock.Internal.MockArgumentMatcher<bool> endOfMessage = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::System.ReadOnlyMemory<byte> buffer, global::System.Net.WebSockets.WebSocketMessageType messageType, global::System.Net.WebSockets.WebSocketMessageFlags messageFlags, global::System.Threading.CancellationToken cancellationToken)> SendAsync(SourceMock.Internal.MockArgumentMatcher<global::System.ReadOnlyMemory<byte>> buffer = default, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageType> messageType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Net.WebSockets.WebSocketMessageFlags> messageFlags = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockPropertyCalls<global::System.Net.WebSockets.WebSocketCloseStatus?> CloseStatus { get; }
        SourceMock.Interfaces.IMockPropertyCalls<string?> CloseStatusDescription { get; }
        SourceMock.Interfaces.IMockPropertyCalls<global::System.Net.WebSockets.WebSocketState> State { get; }
        SourceMock.Interfaces.IMockPropertyCalls<string?> SubProtocol { get; }
    }
}