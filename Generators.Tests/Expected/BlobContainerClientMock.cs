#nullable enable
namespace Azure.Storage.Blobs.Mocks {
    internal class BlobContainerClientMock : global::Azure.Storage.Blobs.BlobContainerClient, IBlobContainerClientSetup, IBlobContainerClientCalls, SourceMock.IMock<global::Azure.Storage.Blobs.BlobContainerClient> {
        public IBlobContainerClientSetup Setup => this;
        public IBlobContainerClientCalls Calls => this;

        private readonly SourceMock.Internal.MockMethodHandler _getBlobBaseClientCoreHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlobBaseClient>, global::Azure.Storage.Blobs.Specialized.BlobBaseClient> IBlobContainerClientSetup.GetBlobBaseClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getBlobBaseClientCoreHandler.Setup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlobBaseClient>, global::Azure.Storage.Blobs.Specialized.BlobBaseClient>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName });
        protected override global::Azure.Storage.Blobs.Specialized.BlobBaseClient GetBlobBaseClientCore(string blobName) => _getBlobBaseClientCoreHandler.Call<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlobBaseClient>, global::Azure.Storage.Blobs.Specialized.BlobBaseClient>(null, new object?[] { blobName });
        System.Collections.Generic.IReadOnlyList<string> IBlobContainerClientCalls.GetBlobBaseClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getBlobBaseClientCoreHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName }, args => ((string)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _getBlobClientHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.BlobClient>, global::Azure.Storage.Blobs.BlobClient> IBlobContainerClientSetup.GetBlobClient(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getBlobClientHandler.Setup<System.Func<string, global::Azure.Storage.Blobs.BlobClient>, global::Azure.Storage.Blobs.BlobClient>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName });
        public override global::Azure.Storage.Blobs.BlobClient GetBlobClient(string blobName) => _getBlobClientHandler.Call<System.Func<string, global::Azure.Storage.Blobs.BlobClient>, global::Azure.Storage.Blobs.BlobClient>(null, new object?[] { blobName });
        System.Collections.Generic.IReadOnlyList<string> IBlobContainerClientCalls.GetBlobClient(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getBlobClientHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName }, args => ((string)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _getBlockBlobClientCoreHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlockBlobClient>, global::Azure.Storage.Blobs.Specialized.BlockBlobClient> IBlobContainerClientSetup.GetBlockBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getBlockBlobClientCoreHandler.Setup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlockBlobClient>, global::Azure.Storage.Blobs.Specialized.BlockBlobClient>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName });
        protected override global::Azure.Storage.Blobs.Specialized.BlockBlobClient GetBlockBlobClientCore(string blobName) => _getBlockBlobClientCoreHandler.Call<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlockBlobClient>, global::Azure.Storage.Blobs.Specialized.BlockBlobClient>(null, new object?[] { blobName });
        System.Collections.Generic.IReadOnlyList<string> IBlobContainerClientCalls.GetBlockBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getBlockBlobClientCoreHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName }, args => ((string)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _getAppendBlobClientCoreHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.AppendBlobClient>, global::Azure.Storage.Blobs.Specialized.AppendBlobClient> IBlobContainerClientSetup.GetAppendBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getAppendBlobClientCoreHandler.Setup<System.Func<string, global::Azure.Storage.Blobs.Specialized.AppendBlobClient>, global::Azure.Storage.Blobs.Specialized.AppendBlobClient>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName });
        protected override global::Azure.Storage.Blobs.Specialized.AppendBlobClient GetAppendBlobClientCore(string blobName) => _getAppendBlobClientCoreHandler.Call<System.Func<string, global::Azure.Storage.Blobs.Specialized.AppendBlobClient>, global::Azure.Storage.Blobs.Specialized.AppendBlobClient>(null, new object?[] { blobName });
        System.Collections.Generic.IReadOnlyList<string> IBlobContainerClientCalls.GetAppendBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getAppendBlobClientCoreHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName }, args => ((string)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _getPageBlobClientCoreHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.PageBlobClient>, global::Azure.Storage.Blobs.Specialized.PageBlobClient> IBlobContainerClientSetup.GetPageBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getPageBlobClientCoreHandler.Setup<System.Func<string, global::Azure.Storage.Blobs.Specialized.PageBlobClient>, global::Azure.Storage.Blobs.Specialized.PageBlobClient>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName });
        protected override global::Azure.Storage.Blobs.Specialized.PageBlobClient GetPageBlobClientCore(string blobName) => _getPageBlobClientCoreHandler.Call<System.Func<string, global::Azure.Storage.Blobs.Specialized.PageBlobClient>, global::Azure.Storage.Blobs.Specialized.PageBlobClient>(null, new object?[] { blobName });
        System.Collections.Generic.IReadOnlyList<string> IBlobContainerClientCalls.GetPageBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName) => _getPageBlobClientCoreHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName }, args => ((string)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _getBlobLeaseClientCoreHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlobLeaseClient>, global::Azure.Storage.Blobs.Specialized.BlobLeaseClient> IBlobContainerClientSetup.GetBlobLeaseClientCore(SourceMock.Internal.MockArgumentMatcher<string> leaseId) => _getBlobLeaseClientCoreHandler.Setup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlobLeaseClient>, global::Azure.Storage.Blobs.Specialized.BlobLeaseClient>(null, new SourceMock.Internal.IMockArgumentMatcher[] { leaseId });
        protected override global::Azure.Storage.Blobs.Specialized.BlobLeaseClient GetBlobLeaseClientCore(string leaseId) => _getBlobLeaseClientCoreHandler.Call<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlobLeaseClient>, global::Azure.Storage.Blobs.Specialized.BlobLeaseClient>(null, new object?[] { leaseId });
        System.Collections.Generic.IReadOnlyList<string> IBlobContainerClientCalls.GetBlobLeaseClientCore(SourceMock.Internal.MockArgumentMatcher<string> leaseId) => _getBlobLeaseClientCoreHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { leaseId }, args => ((string)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _createHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> IBlobContainerClientSetup.Create(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo> Create(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken) => _createHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new object?[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.Create(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IDictionary<string, string>)args[1]!, (global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _create2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> IBlobContainerClientSetup.Create(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _create2Handler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo> Create(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken) => _create2Handler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new object?[] { publicAccessType, metadata, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.Create(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _create2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IDictionary<string, string>)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _createAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> IBlobContainerClientSetup.CreateAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> CreateAsync(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken) => _createAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new object?[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.CreateAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IDictionary<string, string>)args[1]!, (global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _createAsync2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> IBlobContainerClientSetup.CreateAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createAsync2Handler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> CreateAsync(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken) => _createAsync2Handler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new object?[] { publicAccessType, metadata, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.CreateAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createAsync2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IDictionary<string, string>)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _createIfNotExistsHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> IBlobContainerClientSetup.CreateIfNotExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createIfNotExistsHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo> CreateIfNotExists(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken) => _createIfNotExistsHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new object?[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.CreateIfNotExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createIfNotExistsHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IDictionary<string, string>)args[1]!, (global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _createIfNotExists2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> IBlobContainerClientSetup.CreateIfNotExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createIfNotExists2Handler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo> CreateIfNotExists(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken) => _createIfNotExists2Handler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new object?[] { publicAccessType, metadata, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.CreateIfNotExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createIfNotExists2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IDictionary<string, string>)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _createIfNotExistsAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> IBlobContainerClientSetup.CreateIfNotExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createIfNotExistsAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> CreateIfNotExistsAsync(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken) => _createIfNotExistsAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new object?[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.CreateIfNotExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createIfNotExistsAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, encryptionScopeOptions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IDictionary<string, string>)args[1]!, (global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _createIfNotExistsAsync2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> IBlobContainerClientSetup.CreateIfNotExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createIfNotExistsAsync2Handler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> CreateIfNotExistsAsync(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken) => _createIfNotExistsAsync2Handler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new object?[] { publicAccessType, metadata, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.CreateIfNotExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _createIfNotExistsAsync2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { publicAccessType, metadata, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IDictionary<string, string>)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _deleteHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response>, global::Azure.Response> IBlobContainerClientSetup.Delete(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response>, global::Azure.Response>(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken });
        public override global::Azure.Response Delete(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _deleteHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response>, global::Azure.Response>(null, new object?[] { conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.Delete(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _deleteAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response>>, global::System.Threading.Tasks.Task<global::Azure.Response>> IBlobContainerClientSetup.DeleteAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response>>, global::System.Threading.Tasks.Task<global::Azure.Response>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response> DeleteAsync(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _deleteAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response>>, global::System.Threading.Tasks.Task<global::Azure.Response>>(null, new object?[] { conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.DeleteAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _deleteIfExistsHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>> IBlobContainerClientSetup.DeleteIfExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteIfExistsHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken });
        public override global::Azure.Response<bool> DeleteIfExists(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _deleteIfExistsHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>>(null, new object?[] { conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.DeleteIfExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteIfExistsHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _deleteIfExistsAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>> IBlobContainerClientSetup.DeleteIfExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteIfExistsAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<bool>> DeleteIfExistsAsync(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _deleteIfExistsAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>(null, new object?[] { conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.DeleteIfExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteIfExistsAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _existsHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>> IBlobContainerClientSetup.Exists(SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _existsHandler.Setup<System.Func<global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { cancellationToken });
        public override global::Azure.Response<bool> Exists(global::System.Threading.CancellationToken cancellationToken) => _existsHandler.Call<System.Func<global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>>(null, new object?[] { cancellationToken });
        System.Collections.Generic.IReadOnlyList<global::System.Threading.CancellationToken> IBlobContainerClientCalls.Exists(SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _existsHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { cancellationToken }, args => ((global::System.Threading.CancellationToken)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _existsAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>> IBlobContainerClientSetup.ExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _existsAsyncHandler.Setup<System.Func<global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<bool>> ExistsAsync(global::System.Threading.CancellationToken cancellationToken) => _existsAsyncHandler.Call<System.Func<global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>(null, new object?[] { cancellationToken });
        System.Collections.Generic.IReadOnlyList<global::System.Threading.CancellationToken> IBlobContainerClientCalls.ExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _existsAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { cancellationToken }, args => ((global::System.Threading.CancellationToken)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _getPropertiesHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>> IBlobContainerClientSetup.GetProperties(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getPropertiesHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties> GetProperties(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _getPropertiesHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>(null, new object?[] { conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.GetProperties(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getPropertiesHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _getPropertiesAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>> IBlobContainerClientSetup.GetPropertiesAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getPropertiesAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>> GetPropertiesAsync(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _getPropertiesAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>>(null, new object?[] { conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.GetPropertiesAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getPropertiesAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _setMetadataHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> IBlobContainerClientSetup.SetMetadata(SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _setMetadataHandler.Setup<System.Func<global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { metadata, conditions, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo> SetMetadata(global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _setMetadataHandler.Call<System.Func<global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new object?[] { metadata, conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.SetMetadata(SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _setMetadataHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { metadata, conditions, cancellationToken }, args => ((global::System.Collections.Generic.IDictionary<string, string>)args[0]!, (global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _setMetadataAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> IBlobContainerClientSetup.SetMetadataAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _setMetadataAsyncHandler.Setup<System.Func<global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { metadata, conditions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> SetMetadataAsync(global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _setMetadataAsyncHandler.Call<System.Func<global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new object?[] { metadata, conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.SetMetadataAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _setMetadataAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { metadata, conditions, cancellationToken }, args => ((global::System.Collections.Generic.IDictionary<string, string>)args[0]!, (global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _getAccessPolicyHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>> IBlobContainerClientSetup.GetAccessPolicy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getAccessPolicyHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy> GetAccessPolicy(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _getAccessPolicyHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>(null, new object?[] { conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.GetAccessPolicy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getAccessPolicyHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _getAccessPolicyAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>> IBlobContainerClientSetup.GetAccessPolicyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getAccessPolicyAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>> GetAccessPolicyAsync(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _getAccessPolicyAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>>(null, new object?[] { conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.GetAccessPolicyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getAccessPolicyAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _setAccessPolicyHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> IBlobContainerClientSetup.SetAccessPolicy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> accessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>> permissions, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _setAccessPolicyHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { accessType, permissions, conditions, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo> SetAccessPolicy(global::Azure.Storage.Blobs.Models.PublicAccessType accessType, global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier> permissions, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _setAccessPolicyHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>(null, new object?[] { accessType, permissions, conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType accessType, global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier> permissions, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.SetAccessPolicy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> accessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>> permissions, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _setAccessPolicyHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { accessType, permissions, conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>)args[1]!, (global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _setAccessPolicyAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> IBlobContainerClientSetup.SetAccessPolicyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> accessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>> permissions, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _setAccessPolicyAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { accessType, permissions, conditions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> SetAccessPolicyAsync(global::Azure.Storage.Blobs.Models.PublicAccessType accessType, global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier> permissions, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _setAccessPolicyAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>(null, new object?[] { accessType, permissions, conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType accessType, global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier> permissions, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.SetAccessPolicyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> accessType, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>> permissions, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _setAccessPolicyAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { accessType, permissions, conditions, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.PublicAccessType)args[0]!, (global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>)args[1]!, (global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _getBlobsHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem>> IBlobContainerClientSetup.GetBlobs(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states, SourceMock.Internal.MockArgumentMatcher<string> prefix, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getBlobsHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { traits, states, prefix, cancellationToken });
        public override global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem> GetBlobs(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string prefix, global::System.Threading.CancellationToken cancellationToken) => _getBlobsHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem>>(null, new object?[] { traits, states, prefix, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string prefix, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.GetBlobs(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states, SourceMock.Internal.MockArgumentMatcher<string> prefix, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getBlobsHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { traits, states, prefix, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobTraits)args[0]!, (global::Azure.Storage.Blobs.Models.BlobStates)args[1]!, (string)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _getBlobsAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem>> IBlobContainerClientSetup.GetBlobsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states, SourceMock.Internal.MockArgumentMatcher<string> prefix, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getBlobsAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { traits, states, prefix, cancellationToken });
        public override global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem> GetBlobsAsync(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string prefix, global::System.Threading.CancellationToken cancellationToken) => _getBlobsAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem>>(null, new object?[] { traits, states, prefix, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string prefix, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.GetBlobsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states, SourceMock.Internal.MockArgumentMatcher<string> prefix, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getBlobsAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { traits, states, prefix, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobTraits)args[0]!, (global::Azure.Storage.Blobs.Models.BlobStates)args[1]!, (string)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _getBlobsByHierarchyHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>> IBlobContainerClientSetup.GetBlobsByHierarchy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states, SourceMock.Internal.MockArgumentMatcher<string> delimiter, SourceMock.Internal.MockArgumentMatcher<string> prefix, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getBlobsByHierarchyHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { traits, states, delimiter, prefix, cancellationToken });
        public override global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem> GetBlobsByHierarchy(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string delimiter, string prefix, global::System.Threading.CancellationToken cancellationToken) => _getBlobsByHierarchyHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>(null, new object?[] { traits, states, delimiter, prefix, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string delimiter, string prefix, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.GetBlobsByHierarchy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states, SourceMock.Internal.MockArgumentMatcher<string> delimiter, SourceMock.Internal.MockArgumentMatcher<string> prefix, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getBlobsByHierarchyHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { traits, states, delimiter, prefix, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobTraits)args[0]!, (global::Azure.Storage.Blobs.Models.BlobStates)args[1]!, (string)args[2]!, (string)args[3]!, (global::System.Threading.CancellationToken)args[4]!));

        private readonly SourceMock.Internal.MockMethodHandler _getBlobsByHierarchyAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>> IBlobContainerClientSetup.GetBlobsByHierarchyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states, SourceMock.Internal.MockArgumentMatcher<string> delimiter, SourceMock.Internal.MockArgumentMatcher<string> prefix, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getBlobsByHierarchyAsyncHandler.Setup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { traits, states, delimiter, prefix, cancellationToken });
        public override global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem> GetBlobsByHierarchyAsync(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string delimiter, string prefix, global::System.Threading.CancellationToken cancellationToken) => _getBlobsByHierarchyAsyncHandler.Call<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>(null, new object?[] { traits, states, delimiter, prefix, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string delimiter, string prefix, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.GetBlobsByHierarchyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states, SourceMock.Internal.MockArgumentMatcher<string> delimiter, SourceMock.Internal.MockArgumentMatcher<string> prefix, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _getBlobsByHierarchyAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { traits, states, delimiter, prefix, cancellationToken }, args => ((global::Azure.Storage.Blobs.Models.BlobTraits)args[0]!, (global::Azure.Storage.Blobs.Models.BlobStates)args[1]!, (string)args[2]!, (string)args[3]!, (global::System.Threading.CancellationToken)args[4]!));

        private readonly SourceMock.Internal.MockMethodHandler _uploadBlobHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.IO.Stream,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>> IBlobContainerClientSetup.UploadBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::System.IO.Stream> content, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _uploadBlobHandler.Setup<System.Func<string,global::System.IO.Stream,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, content, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo> UploadBlob(string blobName, global::System.IO.Stream content, global::System.Threading.CancellationToken cancellationToken) => _uploadBlobHandler.Call<System.Func<string,global::System.IO.Stream,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>(null, new object?[] { blobName, content, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string blobName, global::System.IO.Stream content, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.UploadBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::System.IO.Stream> content, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _uploadBlobHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, content, cancellationToken }, args => ((string)args[0]!, (global::System.IO.Stream)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _uploadBlobAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.IO.Stream,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>> IBlobContainerClientSetup.UploadBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::System.IO.Stream> content, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _uploadBlobAsyncHandler.Setup<System.Func<string,global::System.IO.Stream,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, content, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>> UploadBlobAsync(string blobName, global::System.IO.Stream content, global::System.Threading.CancellationToken cancellationToken) => _uploadBlobAsyncHandler.Call<System.Func<string,global::System.IO.Stream,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>(null, new object?[] { blobName, content, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string blobName, global::System.IO.Stream content, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.UploadBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::System.IO.Stream> content, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _uploadBlobAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, content, cancellationToken }, args => ((string)args[0]!, (global::System.IO.Stream)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _uploadBlob2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.BinaryData,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>> IBlobContainerClientSetup.UploadBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::System.BinaryData> content, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _uploadBlob2Handler.Setup<System.Func<string,global::System.BinaryData,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, content, cancellationToken });
        public override global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo> UploadBlob(string blobName, global::System.BinaryData content, global::System.Threading.CancellationToken cancellationToken) => _uploadBlob2Handler.Call<System.Func<string,global::System.BinaryData,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>(null, new object?[] { blobName, content, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string blobName, global::System.BinaryData content, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.UploadBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::System.BinaryData> content, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _uploadBlob2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, content, cancellationToken }, args => ((string)args[0]!, (global::System.BinaryData)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _uploadBlobAsync2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.BinaryData,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>> IBlobContainerClientSetup.UploadBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::System.BinaryData> content, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _uploadBlobAsync2Handler.Setup<System.Func<string,global::System.BinaryData,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, content, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>> UploadBlobAsync(string blobName, global::System.BinaryData content, global::System.Threading.CancellationToken cancellationToken) => _uploadBlobAsync2Handler.Call<System.Func<string,global::System.BinaryData,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>(null, new object?[] { blobName, content, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string blobName, global::System.BinaryData content, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.UploadBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::System.BinaryData> content, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _uploadBlobAsync2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, content, cancellationToken }, args => ((string)args[0]!, (global::System.BinaryData)args[1]!, (global::System.Threading.CancellationToken)args[2]!));

        private readonly SourceMock.Internal.MockMethodHandler _deleteBlobHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response>, global::Azure.Response> IBlobContainerClientSetup.DeleteBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteBlobHandler.Setup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response>, global::Azure.Response>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, snapshotsOption, conditions, cancellationToken });
        public override global::Azure.Response DeleteBlob(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _deleteBlobHandler.Call<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response>, global::Azure.Response>(null, new object?[] { blobName, snapshotsOption, conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.DeleteBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteBlobHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, snapshotsOption, conditions, cancellationToken }, args => ((string)args[0]!, (global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption)args[1]!, (global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _deleteBlobAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response>>, global::System.Threading.Tasks.Task<global::Azure.Response>> IBlobContainerClientSetup.DeleteBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteBlobAsyncHandler.Setup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response>>, global::System.Threading.Tasks.Task<global::Azure.Response>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, snapshotsOption, conditions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response> DeleteBlobAsync(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _deleteBlobAsyncHandler.Call<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response>>, global::System.Threading.Tasks.Task<global::Azure.Response>>(null, new object?[] { blobName, snapshotsOption, conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.DeleteBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteBlobAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, snapshotsOption, conditions, cancellationToken }, args => ((string)args[0]!, (global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption)args[1]!, (global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _deleteBlobIfExistsHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>> IBlobContainerClientSetup.DeleteBlobIfExists(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteBlobIfExistsHandler.Setup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, snapshotsOption, conditions, cancellationToken });
        public override global::Azure.Response<bool> DeleteBlobIfExists(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _deleteBlobIfExistsHandler.Call<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>>(null, new object?[] { blobName, snapshotsOption, conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.DeleteBlobIfExists(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteBlobIfExistsHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, snapshotsOption, conditions, cancellationToken }, args => ((string)args[0]!, (global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption)args[1]!, (global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _deleteBlobIfExistsAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>> IBlobContainerClientSetup.DeleteBlobIfExistsAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteBlobIfExistsAsyncHandler.Setup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, snapshotsOption, conditions, cancellationToken });
        public override global::System.Threading.Tasks.Task<global::Azure.Response<bool>> DeleteBlobIfExistsAsync(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken) => _deleteBlobIfExistsAsyncHandler.Call<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>(null, new object?[] { blobName, snapshotsOption, conditions, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.DeleteBlobIfExistsAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _deleteBlobIfExistsAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { blobName, snapshotsOption, conditions, cancellationToken }, args => ((string)args[0]!, (global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption)args[1]!, (global::Azure.Storage.Blobs.Models.BlobRequestConditions)args[2]!, (global::System.Threading.CancellationToken)args[3]!));

        private readonly SourceMock.Internal.MockMethodHandler _findBlobsByTagsHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>> IBlobContainerClientSetup.FindBlobsByTags(SourceMock.Internal.MockArgumentMatcher<string> tagFilterSqlExpression, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _findBlobsByTagsHandler.Setup<System.Func<string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { tagFilterSqlExpression, cancellationToken });
        public override global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem> FindBlobsByTags(string tagFilterSqlExpression, global::System.Threading.CancellationToken cancellationToken) => _findBlobsByTagsHandler.Call<System.Func<string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>(null, new object?[] { tagFilterSqlExpression, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string tagFilterSqlExpression, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.FindBlobsByTags(SourceMock.Internal.MockArgumentMatcher<string> tagFilterSqlExpression, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _findBlobsByTagsHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { tagFilterSqlExpression, cancellationToken }, args => ((string)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _findBlobsByTagsAsyncHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>> IBlobContainerClientSetup.FindBlobsByTagsAsync(SourceMock.Internal.MockArgumentMatcher<string> tagFilterSqlExpression, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _findBlobsByTagsAsyncHandler.Setup<System.Func<string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>(null, new SourceMock.Internal.IMockArgumentMatcher[] { tagFilterSqlExpression, cancellationToken });
        public override global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem> FindBlobsByTagsAsync(string tagFilterSqlExpression, global::System.Threading.CancellationToken cancellationToken) => _findBlobsByTagsAsyncHandler.Call<System.Func<string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>(null, new object?[] { tagFilterSqlExpression, cancellationToken });
        System.Collections.Generic.IReadOnlyList<(string tagFilterSqlExpression, global::System.Threading.CancellationToken cancellationToken)> IBlobContainerClientCalls.FindBlobsByTagsAsync(SourceMock.Internal.MockArgumentMatcher<string> tagFilterSqlExpression, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken) => _findBlobsByTagsAsyncHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { tagFilterSqlExpression, cancellationToken }, args => ((string)args[0]!, (global::System.Threading.CancellationToken)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _generateSasUriHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Sas.BlobContainerSasPermissions,global::System.DateTimeOffset, global::System.Uri>, global::System.Uri> IBlobContainerClientSetup.GenerateSasUri(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Sas.BlobContainerSasPermissions> permissions, SourceMock.Internal.MockArgumentMatcher<global::System.DateTimeOffset> expiresOn) => _generateSasUriHandler.Setup<System.Func<global::Azure.Storage.Sas.BlobContainerSasPermissions,global::System.DateTimeOffset, global::System.Uri>, global::System.Uri>(null, new SourceMock.Internal.IMockArgumentMatcher[] { permissions, expiresOn });
        public override global::System.Uri GenerateSasUri(global::Azure.Storage.Sas.BlobContainerSasPermissions permissions, global::System.DateTimeOffset expiresOn) => _generateSasUriHandler.Call<System.Func<global::Azure.Storage.Sas.BlobContainerSasPermissions,global::System.DateTimeOffset, global::System.Uri>, global::System.Uri>(null, new object?[] { permissions, expiresOn });
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Sas.BlobContainerSasPermissions permissions, global::System.DateTimeOffset expiresOn)> IBlobContainerClientCalls.GenerateSasUri(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Sas.BlobContainerSasPermissions> permissions, SourceMock.Internal.MockArgumentMatcher<global::System.DateTimeOffset> expiresOn) => _generateSasUriHandler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { permissions, expiresOn }, args => ((global::Azure.Storage.Sas.BlobContainerSasPermissions)args[0]!, (global::System.DateTimeOffset)args[1]!));

        private readonly SourceMock.Internal.MockMethodHandler _generateSasUri2Handler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Sas.BlobSasBuilder, global::System.Uri>, global::System.Uri> IBlobContainerClientSetup.GenerateSasUri(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Sas.BlobSasBuilder> builder) => _generateSasUri2Handler.Setup<System.Func<global::Azure.Storage.Sas.BlobSasBuilder, global::System.Uri>, global::System.Uri>(null, new SourceMock.Internal.IMockArgumentMatcher[] { builder });
        public override global::System.Uri GenerateSasUri(global::Azure.Storage.Sas.BlobSasBuilder builder) => _generateSasUri2Handler.Call<System.Func<global::Azure.Storage.Sas.BlobSasBuilder, global::System.Uri>, global::System.Uri>(null, new object?[] { builder });
        System.Collections.Generic.IReadOnlyList<global::Azure.Storage.Sas.BlobSasBuilder> IBlobContainerClientCalls.GenerateSasUri(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Sas.BlobSasBuilder> builder) => _generateSasUri2Handler.Calls(null, new SourceMock.Internal.IMockArgumentMatcher[] { builder }, args => ((global::Azure.Storage.Sas.BlobSasBuilder)args[0]!));

        private readonly SourceMock.Internal.MockMethodHandler _getParentBlobServiceClientCoreHandler = new();
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.BlobServiceClient>, global::Azure.Storage.Blobs.BlobServiceClient> IBlobContainerClientSetup.GetParentBlobServiceClientCore() => _getParentBlobServiceClientCoreHandler.Setup<System.Func<global::Azure.Storage.Blobs.BlobServiceClient>, global::Azure.Storage.Blobs.BlobServiceClient>(null, null);
        protected override global::Azure.Storage.Blobs.BlobServiceClient GetParentBlobServiceClientCore() => _getParentBlobServiceClientCoreHandler.Call<System.Func<global::Azure.Storage.Blobs.BlobServiceClient>, global::Azure.Storage.Blobs.BlobServiceClient>(null, null);
        System.Collections.Generic.IReadOnlyList<SourceMock.NoArguments> IBlobContainerClientCalls.GetParentBlobServiceClientCore() => _getParentBlobServiceClientCoreHandler.Calls(null, null, _ => SourceMock.NoArguments.Value);

        private readonly SourceMock.Internal.MockPropertyHandler<global::System.Uri> _uriHandler = new(false);
        SourceMock.Interfaces.IMockPropertySetup<global::System.Uri> IBlobContainerClientSetup.Uri => _uriHandler.Setup();
        public override global::System.Uri Uri => _uriHandler.GetterHandler.Call<System.Func<global::System.Uri>, global::System.Uri>(null, null);
        SourceMock.Interfaces.IMockPropertyCalls<global::System.Uri> IBlobContainerClientCalls.Uri => _uriHandler.Calls();

        private readonly SourceMock.Internal.MockPropertyHandler<string> _accountNameHandler = new(false);
        SourceMock.Interfaces.IMockPropertySetup<string> IBlobContainerClientSetup.AccountName => _accountNameHandler.Setup();
        public override string AccountName => _accountNameHandler.GetterHandler.Call<System.Func<string>, string>(null, null);
        SourceMock.Interfaces.IMockPropertyCalls<string> IBlobContainerClientCalls.AccountName => _accountNameHandler.Calls();

        private readonly SourceMock.Internal.MockPropertyHandler<string> _nameHandler = new(false);
        SourceMock.Interfaces.IMockPropertySetup<string> IBlobContainerClientSetup.Name => _nameHandler.Setup();
        public override string Name => _nameHandler.GetterHandler.Call<System.Func<string>, string>(null, null);
        SourceMock.Interfaces.IMockPropertyCalls<string> IBlobContainerClientCalls.Name => _nameHandler.Calls();

        private readonly SourceMock.Internal.MockPropertyHandler<bool> _canGenerateSasUriHandler = new(false);
        SourceMock.Interfaces.IMockPropertySetup<bool> IBlobContainerClientSetup.CanGenerateSasUri => _canGenerateSasUriHandler.Setup();
        public override bool CanGenerateSasUri => _canGenerateSasUriHandler.GetterHandler.Call<System.Func<bool>, bool>(null, null);
        SourceMock.Interfaces.IMockPropertyCalls<bool> IBlobContainerClientCalls.CanGenerateSasUri => _canGenerateSasUriHandler.Calls();
    }

    internal interface IBlobContainerClientSetup {
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlobBaseClient>, global::Azure.Storage.Blobs.Specialized.BlobBaseClient> GetBlobBaseClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.BlobClient>, global::Azure.Storage.Blobs.BlobClient> GetBlobClient(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlockBlobClient>, global::Azure.Storage.Blobs.Specialized.BlockBlobClient> GetBlockBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.AppendBlobClient>, global::Azure.Storage.Blobs.Specialized.AppendBlobClient> GetAppendBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.PageBlobClient>, global::Azure.Storage.Blobs.Specialized.PageBlobClient> GetPageBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string, global::Azure.Storage.Blobs.Specialized.BlobLeaseClient>, global::Azure.Storage.Blobs.Specialized.BlobLeaseClient> GetBlobLeaseClientCore(SourceMock.Internal.MockArgumentMatcher<string> leaseId = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> Create(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> Create(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> CreateAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> CreateAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> CreateIfNotExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> CreateIfNotExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> CreateIfNotExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IDictionary<string, string>,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> CreateIfNotExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response>, global::Azure.Response> Delete(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response>>, global::System.Threading.Tasks.Task<global::Azure.Response>> DeleteAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>> DeleteIfExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>> DeleteIfExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>> Exists(SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>> ExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>> GetProperties(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerProperties>>> GetPropertiesAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> SetMetadata(SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::System.Collections.Generic.IDictionary<string, string>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> SetMetadataAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>> GetAccessPolicy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>>> GetAccessPolicyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>> SetAccessPolicy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> accessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>> permissions = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.PublicAccessType,global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContainerInfo>>> SetAccessPolicyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> accessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>> permissions = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobItem>> GetBlobs(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states = default, SourceMock.Internal.MockArgumentMatcher<string> prefix = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobItem>> GetBlobsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states = default, SourceMock.Internal.MockArgumentMatcher<string> prefix = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>> GetBlobsByHierarchy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states = default, SourceMock.Internal.MockArgumentMatcher<string> delimiter = default, SourceMock.Internal.MockArgumentMatcher<string> prefix = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.Models.BlobTraits,global::Azure.Storage.Blobs.Models.BlobStates,string,string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.BlobHierarchyItem>> GetBlobsByHierarchyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states = default, SourceMock.Internal.MockArgumentMatcher<string> delimiter = default, SourceMock.Internal.MockArgumentMatcher<string> prefix = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.IO.Stream,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>> UploadBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::System.IO.Stream> content = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.IO.Stream,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>> UploadBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::System.IO.Stream> content = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.BinaryData,global::System.Threading.CancellationToken, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>, global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>> UploadBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::System.BinaryData> content = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.BinaryData,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>>, global::System.Threading.Tasks.Task<global::Azure.Response<global::Azure.Storage.Blobs.Models.BlobContentInfo>>> UploadBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::System.BinaryData> content = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response>, global::Azure.Response> DeleteBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response>>, global::System.Threading.Tasks.Task<global::Azure.Response>> DeleteBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::Azure.Response<bool>>, global::Azure.Response<bool>> DeleteBlobIfExists(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption,global::Azure.Storage.Blobs.Models.BlobRequestConditions,global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>>, global::System.Threading.Tasks.Task<global::Azure.Response<bool>>> DeleteBlobIfExistsAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.Threading.CancellationToken, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>, global::Azure.Pageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>> FindBlobsByTags(SourceMock.Internal.MockArgumentMatcher<string> tagFilterSqlExpression = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<string,global::System.Threading.CancellationToken, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>>, global::Azure.AsyncPageable<global::Azure.Storage.Blobs.Models.TaggedBlobItem>> FindBlobsByTagsAsync(SourceMock.Internal.MockArgumentMatcher<string> tagFilterSqlExpression = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Sas.BlobContainerSasPermissions,global::System.DateTimeOffset, global::System.Uri>, global::System.Uri> GenerateSasUri(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Sas.BlobContainerSasPermissions> permissions = default, SourceMock.Internal.MockArgumentMatcher<global::System.DateTimeOffset> expiresOn = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Sas.BlobSasBuilder, global::System.Uri>, global::System.Uri> GenerateSasUri(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Sas.BlobSasBuilder> builder = default);
        SourceMock.Interfaces.IMockMethodSetup<System.Func<global::Azure.Storage.Blobs.BlobServiceClient>, global::Azure.Storage.Blobs.BlobServiceClient> GetParentBlobServiceClientCore();
        SourceMock.Interfaces.IMockPropertySetup<global::System.Uri> Uri { get; }
        SourceMock.Interfaces.IMockPropertySetup<string> AccountName { get; }
        SourceMock.Interfaces.IMockPropertySetup<string> Name { get; }
        SourceMock.Interfaces.IMockPropertySetup<bool> CanGenerateSasUri { get; }
    }

    internal interface IBlobContainerClientCalls {
        System.Collections.Generic.IReadOnlyList<string> GetBlobBaseClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        System.Collections.Generic.IReadOnlyList<string> GetBlobClient(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        System.Collections.Generic.IReadOnlyList<string> GetBlockBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        System.Collections.Generic.IReadOnlyList<string> GetAppendBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        System.Collections.Generic.IReadOnlyList<string> GetPageBlobClientCore(SourceMock.Internal.MockArgumentMatcher<string> blobName = default);
        System.Collections.Generic.IReadOnlyList<string> GetBlobLeaseClientCore(SourceMock.Internal.MockArgumentMatcher<string> leaseId = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken)> Create(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken)> Create(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken)> CreateAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken)> CreateAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken)> CreateIfNotExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken)> CreateIfNotExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions encryptionScopeOptions, global::System.Threading.CancellationToken cancellationToken)> CreateIfNotExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions> encryptionScopeOptions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType publicAccessType, global::System.Collections.Generic.IDictionary<string, string> metadata, global::System.Threading.CancellationToken cancellationToken)> CreateIfNotExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> publicAccessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> Delete(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> DeleteAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> DeleteIfExists(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> DeleteIfExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<global::System.Threading.CancellationToken> Exists(SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<global::System.Threading.CancellationToken> ExistsAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> GetProperties(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> GetPropertiesAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> SetMetadata(SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::System.Collections.Generic.IDictionary<string, string> metadata, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> SetMetadataAsync(SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IDictionary<string, string>> metadata = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> GetAccessPolicy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> GetAccessPolicyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType accessType, global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier> permissions, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> SetAccessPolicy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> accessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>> permissions = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.PublicAccessType accessType, global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier> permissions, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> SetAccessPolicyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.PublicAccessType> accessType = default, SourceMock.Internal.MockArgumentMatcher<global::System.Collections.Generic.IEnumerable<global::Azure.Storage.Blobs.Models.BlobSignedIdentifier>> permissions = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string prefix, global::System.Threading.CancellationToken cancellationToken)> GetBlobs(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states = default, SourceMock.Internal.MockArgumentMatcher<string> prefix = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string prefix, global::System.Threading.CancellationToken cancellationToken)> GetBlobsAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states = default, SourceMock.Internal.MockArgumentMatcher<string> prefix = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string delimiter, string prefix, global::System.Threading.CancellationToken cancellationToken)> GetBlobsByHierarchy(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states = default, SourceMock.Internal.MockArgumentMatcher<string> delimiter = default, SourceMock.Internal.MockArgumentMatcher<string> prefix = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Blobs.Models.BlobTraits traits, global::Azure.Storage.Blobs.Models.BlobStates states, string delimiter, string prefix, global::System.Threading.CancellationToken cancellationToken)> GetBlobsByHierarchyAsync(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobTraits> traits = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobStates> states = default, SourceMock.Internal.MockArgumentMatcher<string> delimiter = default, SourceMock.Internal.MockArgumentMatcher<string> prefix = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string blobName, global::System.IO.Stream content, global::System.Threading.CancellationToken cancellationToken)> UploadBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::System.IO.Stream> content = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string blobName, global::System.IO.Stream content, global::System.Threading.CancellationToken cancellationToken)> UploadBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::System.IO.Stream> content = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string blobName, global::System.BinaryData content, global::System.Threading.CancellationToken cancellationToken)> UploadBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::System.BinaryData> content = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string blobName, global::System.BinaryData content, global::System.Threading.CancellationToken cancellationToken)> UploadBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::System.BinaryData> content = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> DeleteBlob(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> DeleteBlobAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> DeleteBlobIfExists(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string blobName, global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption snapshotsOption, global::Azure.Storage.Blobs.Models.BlobRequestConditions conditions, global::System.Threading.CancellationToken cancellationToken)> DeleteBlobIfExistsAsync(SourceMock.Internal.MockArgumentMatcher<string> blobName = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.DeleteSnapshotsOption> snapshotsOption = default, SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Blobs.Models.BlobRequestConditions> conditions = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string tagFilterSqlExpression, global::System.Threading.CancellationToken cancellationToken)> FindBlobsByTags(SourceMock.Internal.MockArgumentMatcher<string> tagFilterSqlExpression = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(string tagFilterSqlExpression, global::System.Threading.CancellationToken cancellationToken)> FindBlobsByTagsAsync(SourceMock.Internal.MockArgumentMatcher<string> tagFilterSqlExpression = default, SourceMock.Internal.MockArgumentMatcher<global::System.Threading.CancellationToken> cancellationToken = default);
        System.Collections.Generic.IReadOnlyList<(global::Azure.Storage.Sas.BlobContainerSasPermissions permissions, global::System.DateTimeOffset expiresOn)> GenerateSasUri(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Sas.BlobContainerSasPermissions> permissions = default, SourceMock.Internal.MockArgumentMatcher<global::System.DateTimeOffset> expiresOn = default);
        System.Collections.Generic.IReadOnlyList<global::Azure.Storage.Sas.BlobSasBuilder> GenerateSasUri(SourceMock.Internal.MockArgumentMatcher<global::Azure.Storage.Sas.BlobSasBuilder> builder = default);
        System.Collections.Generic.IReadOnlyList<SourceMock.NoArguments> GetParentBlobServiceClientCore();
        SourceMock.Interfaces.IMockPropertyCalls<global::System.Uri> Uri { get; }
        SourceMock.Interfaces.IMockPropertyCalls<string> AccountName { get; }
        SourceMock.Interfaces.IMockPropertyCalls<string> Name { get; }
        SourceMock.Interfaces.IMockPropertyCalls<bool> CanGenerateSasUri { get; }
    }
}